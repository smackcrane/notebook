import { Footnote } from '../src/footnote.jsx'

# This Website II: Build

In <a href="this-website-i.html">Part I</a>, we set up the site with a couple of bonus features on top of plain HTML, most notably fancy footnotes<Footnote>Like this.</Footnote> that expand in place when clicked.

Careful readers will remember that this was possible with plain HTML and CSS, but required a fair bit of it. Here's the code for footnote 1 above:

```
<label for="fn-1-toggle">
    <sup>1</sup>
</label>
<input type="checkbox" hidden="" id="fn-1-toggle" />
<div class="fn-content">
    Like this.
</div>
```

Not the most pleasant writing experience, to say the least.
<Footnote>
    As another example, the angle brackets &lt; and &gt; are special characters
    in HTML---so to actually display the code above, the HTML would have to look
    like this.
```
&lt;label for="fn-1-toggle"&gt;
    &lt;sup&gt;1&lt;/sup&gt;
&lt;/label&gt; &lt;input type="checkbox" hidden="" id="fn-1-toggle" /&gt;
&lt;div class="fn-content"&gt;
    Like this.
&lt;/div&gt;
```
</Footnote>

A much more pleasant way to write would be `<Footnote>Like this.</Footnote>`. And maybe do away with all that `<head>` and `<body>` and `<h1>` faffing.<Footnote>And maybe write code like `` `<div>` ``, instead of `<code>&lt;div&gt;</code>`.</Footnote> Luckily, this is all possible, with the power of MDX! <a href="https://mdxjs.com/">MDX</a> is markdown + jsx, which means we can write in markdown rather than HTML, and also write custom components like `<Footnote>` and drop them right in.

Of course, this opens up a whole can of worms. We're writing a website, so it needs to be HTML eventually, so it needs to get compiled, and our custom components need to be included, and if we want to write `import` then it suddenly becomes an "ESM module", which means it needs a "bundler", and---suddenly the project is ballooning out of proportion, all just because we didn't want to write `<label>` quite so many times.

The impression that I've gotten following this rabbit hole is that there are many complicated and annoying things that people want to do with websites, and as a result there are many complicated tools to make things less annoying. But if you're just trying to write a static site, you don't need any of them!<Footnote>In fact, it took me a while to get my bearings here. There was a version of this site that was a single page application with a bunch of React states and context managing everything, bundled with Vite. Eventually I found it was going to be a pain to make navigation work the way I wanted, which was when I finally started to think that there must be a way to just make HTML files. Even then, it took some searching through existing tools<Footnote>There's a Vite plugin `vite-plugin-ssr` that can do this! How do I set it up? Oh wait, <small>it's now <small>its own framework. Let's see, <small>can I use it together with Vite, <small>or do I have to migrate? <small>Hmmm</small></small></small></small></small></Footnote> before it occurred to me that I could just do it myself.</Footnote> If you want to end up with HTML, but start out with something else, you need

1. a compiler (or transpiler).

That's it! Of course, you still have to find the right compiler for your setup. Since I want to write MDX and define my own components, it's enough to use `esbuild` with the `@mdx-js/esbuild` plugin. That whole part of the process looks like this:<Footnote>`npm i esbuild @mdx-js/esbuild react react-dom`</Footnote>

```
import esbuild from 'esbuild'
import mdx from '@mdx-js/esbuild'

await esbuild.build({
    entryPoints: ['pages/*.mdx'],
    outdir: 'out',
    bundle: true,
    format: 'esm',
    platform: 'node',
    plugins: [mdx()],
})
```

This tells `esbuild` to go through all the MDX files in `pages/`, compile them (along with their imports, etc.), and put the result in `out/`.

Since we've eschewed all those fancy bundlers, we still have some more work to do---what this step spits out isn't a finished website. For each MDX page, we now have a Javascript file that produces that page's content. What remains is to convert it to HTML, wrap it in the trappings of an HTML webpage, and assemble them into a full site.

But the point is that this is easy, and doing it by hand gives us a lot of flexibility. To convert the compiled Javascript for `${slug}.mdx` to HTML, we have a handy function provided by React:
```
import { renderToString } from 'react-dom/server'

const { default: Content } = await import(`./out/${slug}.js`)
html = renderToString(Content())
```
This produces HTML, but it still doesn't have the full page structure of `<html>`, `<head>`, `<body>`, etc. For our purposes, this boilerplate will be the same every time, so we can just write it as a string and insert the rendered `html` string in the appropriate place. Now that we have a fully-formed page, we can write it to our output directory (say, `dist/`).

And that's the whole process! Just repeat for each page, copy static assets (pictures, scripts, etc.) over to `dist/`, throw that all those steps together in `build.js`, and we've got our own static site generator!

Well, that's not the *whole* process. Since we're writing it ourselves, we can do whatever else we want! Old HTML files from the previous version of this site? No need to rewrite them in MDX, just copy them through to `dist/`. Posts in a series with their own navigation? Just a couple tweaks to our HTML boilerplate function. Whatever new features come to mind writing the next one? You bet!
